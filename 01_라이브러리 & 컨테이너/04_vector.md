# vector

\# include \<vector>를 선언함으로서 사용할 수 있습니다.

원소들이 선형으로 배열되어 있습니다.

인덱스를 통해서 바로 접근할 수 있습니다. 이 때 걸리는 시간은 상수 시간입니다.

끝에 원소를 추가하거나 제거할 수 있습니다. 이 역시 상수 시간이 소요됩니다.

<br>

* **생성자** 
  * 타입은 편의상 int로 지정합니다.
  * vecotr\<int> v;
    * 비어있는 벡터
  * vector\<int> v(5); 
    * int의 기본값인 0를 5개 가지는 벡터
  * vector\<int> v(5, 2);
    * 2를 5개 가지는 벡터
  * vector\<int> v(v1);
    * v1를 복사한 벡터

<br>

* **assign(개수, 값)**
  * 값을 개수만큼 가지도록 변경

<br>

* **at(인덱스)**
  * 인덱스에 위치한 원소를 반환합니다
  * [] 연산자보다 느리지만, 범위를 확인하므로 더 안전합니다.

<br>

* **front() / back()**
  * 첫번째 / 마지막 원소를 반환합니다.

<br>

* **clear()**
  * 원소들을 제거합니다.
  * size는 줄어들지만 capacity는 변하지 않습니다.

<br>

* **push_back(값) / pop_back()**
  * 뒤에 값을 삽입하거나 제거합니다.

<br>

* **begin() - end() / rbegin() - rend()**
  * 첫 번째 원소-마지막 원소 다음 / 마지막 원소 - 첫 번째 원소 다음을 가리킵니다.

<br>

* **reverse(길이)**
  * 길이만큼 원소를 저장할 공간을 할당합니다.

<br>

* **resize(길이, 값=0)**
  * 길이를 변경합니다.
  * 빈 공간은 인자로 받은 값으로 초기화합니다.

<br>

* size()
  * 원소의 개수를 반환합니다.

<br>

* capacity()
  * 할당된 공간의 크기를 반환합니다.

<br>

* swap(벡터)

  * 호출한 벡터와 인자 벡터의 원소와 capacity를 교환합니다.
  * 벡터의 capacity를 없애고 싶을 때(프로그램이 끝나기 전에 메모리를 확보하고 싶을 때) 사용이 가능합니다.

  ``` c++
  vector<int>().swap(v);
  ```

<br>

* insert(위치, 개수=1, 값)
  * 위치에 값을 개수만큼 삽입합니다.
  * 삽입한 곳의 iterator를 반환합니다.

<br>

* erase(시작 반복자, 마지막 반복자=end)
  * 인자의 범위의 원소들을 삭제합니다.
  * capacity는 변하지 않습니다.

<br>

* empty()
  * 벡터가 비었는지 여부를 논리형으로 반환합니다.

<br>







