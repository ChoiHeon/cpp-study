# Memory Fragmentation

* 메모리 단편화
* 힙에 메모리를 할당 및 해제하는 과정을 반복하면 작은 메모리 공간만이 남을 수 있음
* 이럴 경우 특정 크기 이상의 메모리를 저장할 수 없기 때문에 문제가 발생



### Example

```c++
#define K (1024)

// Assume that heap's size is 10K.

char *p1 = (char*)malloc(3*K);
char *p2 = (char*)malloc(4*K);

// Rested heap's size is 3K.

free(p1);

// Rested heap's size is 7K.

p1 = (char*)malloc(4*K); 	// It can occur an error! 
							// there is not a 4K contiguous block,
```

* 힙의 크기가 10K라고 할 때, 남은 공간이 6K임에도 불구하고 연속된 공간이 아니기 때문에 할당 실패할 수 있음



### 해결 방법

1. 위의 예시처럼 메모리 단편화의 발생 가능성을 얘기했지만, 실제 메모리 할당 함수(ex. malloc, new 등)은 메모리 단편화를 방지하기 위한 알고리즘이 포함되어 있습니다.

2. 운영체제의 LFH(Low Fragmentation Heap)은 운영체제에서 마련한 합의 단편화를 줄여주는 기법

3. 연단위의 고가용성이요구되면 아래의 두 가지 방법으로 해결 가능

   1. 자체 메모리 풀 : 필요한 메모리(객체)를 미리 생성. 필요시 메모리 풀에서 객체를 받은 뒤 사용 후 반환
   2. private heap : 주어진 힙이 아닌, 필요 시 별도로 힙 영역을 만들고 이 영역 자체를 제거함으로서 메모리 할당의 흔적조차 남기지 않은 방법

   * 이러한 방법들은 반드시 필요하지 않으면 구현하지 않아도 OK



### Example - LFH

* 힙에 충분한 크기의 메모리가 준비되어도 연속적이지 않을 경우 할당에 실패할 수 있음
* LFH는 이를 해결하기 위한 기법
* Windows의 LFH는 16KB 이하의 여러 메모리 크기들을 준비한 후, 메모리 할당이 필요하면 해당 크기를 포함하면서 가장 작은 메모리를 할당, 이 때 각 분리된 메모리들을 bucket이라 부름



**[Bucket의 구성]**

| Buckets | Granularity | Ranges     |
| ------- | ----------- | ---------- |
| 1~32    | 8           | 1~256      |
| 33~48   | 16          | 257~512    |
| 49~64   | 32          | 513~1024   |
| 65~8-   | 64          | 1025~2048  |
| 81~96   | 128         | 2049~4096  |
| 97~112  | 256         | 4097~8192  |
| 113~128 | 512         | 8193~16384 |

* 1~32번호의 bucket은 각각 8, 16, ... , 256 byte를 할당받은 공간 (8 byte 씩 증가)
*  33~48은  각각 272(256+16), 288 , ... , 512 byte를 할당받은 공간 (16 byte 씩 증가)

* 만약 10 byte를 할당하려면 16 byte를 가지고 있는 2번 bucket을 선택합니다.



**[LFH 장점]**

* 멀티스레드 환경에서 메모리 할당이 빈번하고 16 KB이하의 메모리를 할당할 때 속도가 빠름
* 시스템 차원에서 사용하므로 일반적인 메모리 할당 함수에도 적용됨



**[LFH 단점]**

* 16 KB를 초과하면 적용 X
* `HEAP_NO_SERIALIZE`로 생성된 힙에는 적용되지 않음
  * `HEAP_NO_SERIALIZE`은 멀티스레드 환경에서 여러 스레드가 lock 없이 해당 힙에 접근할 수 있음



