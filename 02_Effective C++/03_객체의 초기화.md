# 객체의 초기화

* c++의 객체(변수) 초기화 규칙은 명확히 존재하긴 하나, 확실한 초기화를 보장하지는 않습니다.
* 따라서 모든 객체는 사용하기 전에 항상 초기화가 수행되어야 합니다.



### 대입과 초기화

* 일반적으로 클래스의 생성자에서 사용되는 방법입니다.
* 다음은 대입을 사용한 생성자 구현입니다.

```c++
class Person {
private:
    int age;
    string name;
public: 
    Person(int _age, string _name) {
    	age = _age;		// 대입
        name = _name;	// 대입
	}
}
```

* c++의 규칙에 의하면 멤버 변수는 생성자가 실행되기 전에 초기화되어야 하기 때문에 이는 올바른 구현이 아닙니다.
* 다음은 대입 대신 초기화 리스트를 사용하는 방법입니다.

```c++
class Person {
private:
    int age;
    string name;
public:
    Person(int _age, string _name) : age(_age), name(_name) // 초기화
    { }
}
```

* 초기화 리스트는 대입보다 더 성능이 높습니다.

  * 대입으로 생성자를 구현했을 경우,  각 멤버 변수(기본 타입이 아닌)에 대한 기본 생성자가 호출되어 미리 초기화가 됩니다.
  * 이후, 초기화된 각 멤버 변수에 대해서 값을 대입하므로 총 두 번의 과정을 거치게 됩니다.
  * 하지만 초기화 리스트를 사용하면 생성자의 매개변수가 각 멤버 변수의 생성자의 인자로 사용되기 때문에 총 1번의 과정을 거치게 됩니다.

* 초기화 리스트를 사용할 때는 아래의 규칙에 따르는 좋습니다.

  1. 기본 타입 여부와 상관없이 모든 멤버 변수는 초기화 리스트에 넣어야 합니다.
     * 상수 또는 참조형 변수는 대입이 불가능하기 때문에 초기화 리스트를 사용하지 않을 경우 에러가 발생할 수 있습니다.
     * 특정 멤버 변수가 초기화되지 않는 상황을 미리 방지할 수 있습니다.

  2. 만약 생성자에서 멤버 변수를 특정 값으로 초기화할 생각이 없더라도 초기화 리스트를 사용하는 습관을 들이는 것이 좋습니다.

     ```c++
     Person() : age(), name() 
     {}
     ```

  3. 멤버 변수의 선언 순서와 초기화 리스트 내의 순서가 일치해야 합니다.

     * 초기화는 초기화 리스트 내의 순서가 아닌, 멤버 변수 선언 순서에 따라 수행됩니다.
     * 따라서 순서를 동일하게 하면 얘기치 못한 버그 발생 시, 좀 더 문제점을 찾기가 수월해집니다.

