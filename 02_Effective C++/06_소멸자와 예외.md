# 소멸자와 예외

### 항목 8. 소멸자 내에서 예외가 발생할 경우

* 클래스를 정의할 때 소멸자에서 예외가 발생할 경우 의도치 않은 동작이 발생할 수 있습니다.

  ```c++
  class AAA {
  public:
      ~AAA() {
          // 생략
      }
  }
  
  void func() {
      vector<AAA> v;
  }
  ```

  * 만약 v에 AAA 객체 10개가 있다고 가정할 때, 첫 번째 AAA의 소멸자에서 예외가 발생하면 `vector`는 나머지 요소들(AAA 객체들)의 소멸자를 호출합니다.
  * 이 과정에서 다시 한 번 소멸자에서 예외가 발생한다면 동시에 여러 예외가 발생한 것이므로 의도치 않은 상황이 발생할 수 있습니다.

* 다음 코드는 소멸자에서 예외를 처리하는 방법입니다.

  ```c++
  class DBConnection {
  public:
      static DBConnection create() {
          // 생략
      }
      void close();
  }
  
  class DBConn {
  public:
      ~DBConn();
      
  private:
      DBConnection db;
  }
  
  // 1. 예외가 발생하면 프로그램을 종료
  DBConn::~DBConn() {
      try {
          db.close();
      } catch (...) {
          // 로그 출력
          std::abort();
      }
  }
  
  // 2. 예외를 무시
  DBConn::~DBConn() {
      try {
          db.close();
      } catch (...) {
          // 로그 출력
      }
  }
  ```

  * 1번은 좋은 방법일 수 있자만, 2번의 경우 에러를 무시함으로서 이후 정상적인 동작을 보장할 수 없을 경우 좋은 방법이라 할 수 없습니다.
  * 1번, 2번 모두 예외 발생에 대해서 프로그램이 어떠한 조치를 취할 수 없다는 문제점이 있습니다.

### 해결 방법

* 위의 문제에서 사용자가 대처할 수 있는 기회를 제공함으로서 책임을 사용자에게 넘길 수 있습니다.

  ```c++
  class DBConn {
  public:
      void cloas() {
          db.close();
          closed = true;
      }
      ~DBConn() {
          if (!closed) {
              try {
                  db.close();
              } catch (...) {
                  // 로그 출력
                  // 예외를 무시하거나 프로그램을 종료
              }
          }
      }
      
  private:
      DBConnection db;
      bool closed;
  }
  ```

  * `DBConn::close()` 를  통해 사용자에게 책임을 넘깁니다.

* 위의 코드는 사용 방법이 어려운 인터페이스를 제공한다는 단점이 있지만 <u>예외를 소멸자가 아닌 다른 함수에서 비롯되게 한다는 점이 중요합니다.</u>

### 정리

1. 소멸자에서 예외는 빠져나가면 안됩니다.
   * 만약 소멸자 안에서 호출된 함수가 예외를 발생시킨다면, 해당 예외를 무시하거나 프로그램을 종료시키는 등의 대처가 필요합니다.
2. 클래스의 작업 도중에 발생한 예외를 사용자가 인지하고 대처할 필요가 있다면, 해당 작업을 제공하는 함수는 일반 함수여야 합니다.
   * 즉, 예외를 소멸자가 아닌 함수가 발생시켜야 합니다.